from tkinter import *


from tkinter import scrolledtext

# Tokens for the demo; these would usually be generated by tokenizing user input
Mytokens = [
    ("id", "myvar"), ("op", "="), ("int", "5"), ("op", "*"), ("float", "4.3"),
    ("op", "+"), ("float", "2.1"), ("sep", ";")
]
inToken = ("empty", "empty")

# Accept token from list
def accept_token(output_box):
    global inToken
    output_box.insert(tk.END, f"     accept token from the list: {inToken[1]}\n")
    if Mytokens:
        inToken = Mytokens.pop(0)

# Math function
def math(output_box):
    global inToken
    output_box.insert(tk.END, "\n----parent node math, finding children nodes:\n")

    if inToken[0] == "float":
        output_box.insert(tk.END, f"child node (internal): float\n   float has child node (token): {inToken[1]}\n")
        accept_token(output_box)
    elif inToken[0] == "int":
        output_box.insert(tk.END, f"child node (internal): int\n   int has child node (token): {inToken[1]}\n")
        accept_token(output_box)

        # Loop to handle multiple operations in the expression (e.g., +, *)
        while inToken[1] in ["+", "*"]:
            output_box.insert(tk.END, f"child node (token): {inToken[1]}\n")
            accept_token(output_box)
            if inToken[0] in ["int", "float"]:
                output_box.insert(tk.END, f"child node (internal): {inToken[0]}\n   {inToken[0]} has child node (token): {inToken[1]}\n")
                accept_token(output_box)
            else:
                output_box.insert(tk.END, f"error: math expects int or float after {inToken[1]}\n")
                break
    else:
        output_box.insert(tk.END, "error: math expects float or int\n")

# Exp function
def exp(output_box):
    global inToken
    output_box.insert(tk.END, "\n----parent node exp, finding children nodes:\n")
    typeT, token = inToken

    if typeT == "id":
        output_box.insert(tk.END, f"child node (internal): identifier\n   identifier has child node (token): {token}\n")
        accept_token(output_box)
    else:
        output_box.insert(tk.END, "error: expected identifier as the first element of the expression!\n")
        return

    if inToken[1] == "=":
        output_box.insert(tk.END, f"child node (token): {inToken[1]}\n")
        accept_token(output_box)
    else:
        output_box.insert(tk.END, "error: expected '=' as the second element of the expression!\n")
        return

    output_box.insert(tk.END, "Child node (internal): math\n")
    math(output_box)

# Parse function
def parse(output_box):
    global inToken, Mytokens
    Mytokens = [  # Reset tokens for a fresh parse each time
        ("id", "myvar"), ("op", "="), ("int", "5"), ("op", "*"), ("float", "4.3"),
        ("op", "+"), ("float", "2.1"), ("sep", ";")
    ]
    output_box.delete('1.0', tk.END)
    output_box.insert(tk.END, "Starting parsing process...\n")
    if Mytokens:
        inToken = Mytokens.pop(0)
        output_box.insert(tk.END, f"Initial token: {inToken[1]}\n")
        exp(output_box)
        if inToken[1] == ";":
            output_box.insert(tk.END, "\nparse tree building success!\n")
        else:
            output_box.insert(tk.END, "error: expected ';' at the end\n")
    else:
        output_box.insert(tk.END, "error: token list is empty\n")

# GUI Setup
root = tk.Tk()
root.title("BNF Parser")

# Input field for code
input_label = tk.Label(root, text="Enter code to parse:")
input_label.pack()

# Parse button
parse_button = tk.Button(root, text="Parse", command=lambda: parse(output_box))
parse_button.pack()

# Output area for parsing steps
output_label = tk.Label(root, text="Parse Output:")
output_label.pack()
output_box = scrolledtext.ScrolledText(root, width=60, height=20)
output_box.pack()

root.mainloop()
