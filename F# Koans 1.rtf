{\rtf1\ansi\ansicpg1252\cocoartf2761
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Times-Roman;}
{\colortbl;\red255\green255\blue255;\red79\green123\blue61;\red23\green23\blue23;\red202\green202\blue202;
\red70\green137\blue204;\red212\green212\blue212;\red194\green126\blue101;\red167\green197\blue152;}
{\*\expandedcolortbl;;\cssrgb\c37647\c54510\c30588;\cssrgb\c11765\c11765\c11765;\cssrgb\c83137\c83137\c83137;
\cssrgb\c33725\c61176\c83922;\cssrgb\c86275\c86275\c86275;\cssrgb\c80784\c56863\c47059;\cssrgb\c70980\c80784\c65882;}
\margl1440\margr1440\vieww20780\viewh11200\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs24 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 //Test at https://try.fsharp.org/\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  AssertEquality a b \cf6 \strokec6 =\cf4 \strokec4  \cf5 \strokec5 if\cf4 \strokec4  a\cf6 \strokec6 <>\cf4 \strokec4 b \cf5 \strokec5 then\cf4 \strokec4  printfn \cf7 \strokec7 "Failed!"\cf4 \strokec4  \cf5 \strokec5 else\cf4 \strokec4  printfn \cf7 \strokec7 "Test Success!"\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Overview\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Below is a set of exercises designed to get you familiar\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // with F#. By the time you're done, you'll have a basic\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // understanding of the syntax of F# and learn a little more\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // about functional programming in general.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Answering Problems\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // This is where the fun begins! Each dashed section contains an\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // example designed to teach you a lesson about the F# language.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // If you highlight the code in an example and execute it (use\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Ctrl+Enter or the run button) it will initially fail. Your\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // job is to fill in the blanks to make it pass. With each\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // passing section, you'll learn more about F#, and add another\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // weapon to your F# programming arsenal.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Start by highlighitng the section below and running it. Once\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // you see it fail, replace the __ with 2 to make it pass.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- about asserts -------------------------------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  expected_value \cf6 \strokec6 =\cf4 \strokec4  \cf8 \strokec8 1\cf4 \strokec4  \cf6 \strokec6 +\cf4 \strokec4  \cf8 \strokec8 1\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  actual_value \cf6 \strokec6 =\cf4 \strokec4  \cf8 \strokec8 2\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality expected_value actual_value\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //Easy, right? Try the next one.\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- more about asserts --------------------------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality \cf7 \strokec7 "foo"\cf4 \strokec4  \cf7 \strokec7 "foo"\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // About Let\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // The let keyword is one of the most fundamental parts of F#.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // You'll use it in almost every line of F# code you write, so\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // let's get to know it well! (no pun intended)\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- let binds a name to a value -----------------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  x \cf6 \strokec6 =\cf4 \strokec4  \cf8 \strokec8 50\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality x \cf8 \strokec8 50\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- let infers the type of values when it can ---------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 (* In F#, values created with let are inferred to have a type like\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 "int" for integer values, "string" for text values, and "bool"\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 for true or false values. *)\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  z \cf6 \strokec6 =\cf4 \strokec4  \cf8 \strokec8 50\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  typeOfZ \cf6 \strokec6 =\cf4 \strokec4  z\cf6 \strokec6 .\cf4 \strokec4 GetType\cf6 \strokec6 ()\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality typeOfZ typeof\cf6 \strokec6 <\cf4 \strokec4 int\cf6 \strokec6 >\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  y \cf6 \strokec6 =\cf4 \strokec4  \cf7 \strokec7 "a string"\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  expectedType \cf6 \strokec6 =\cf4 \strokec4  y\cf6 \strokec6 .\cf4 \strokec4 GetType\cf6 \strokec6 ()\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality expectedType typeof\cf6 \strokec6 <\cf4 \strokec4 string\cf6 \strokec6 >\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // ---- you can make the types explicit -------------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  \cf6 \strokec6 (\cf4 \strokec4 x\cf6 \strokec6 :\cf4 \strokec4 int\cf6 \strokec6 )\cf4 \strokec4  \cf6 \strokec6 =\cf4 \strokec4  \cf8 \strokec8 42\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  typeOfX \cf6 \strokec6 =\cf4 \strokec4  x\cf6 \strokec6 .\cf4 \strokec4 GetType\cf6 \strokec6 ()\cf4 \cb1 \strokec4 \
\
\cf5 \cb3 \strokec5 let\cf4 \strokec4  y\cf6 \strokec6 :\cf4 \strokec4 string \cf6 \strokec6 =\cf4 \strokec4  \cf7 \strokec7 "forty two"\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  typeOfY \cf6 \strokec6 =\cf4 \strokec4  y\cf6 \strokec6 .\cf4 \strokec4 GetType\cf6 \strokec6 ()\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality typeOfX typeof\cf6 \strokec6 <\cf4 \strokec4 int\cf6 \strokec6 >\cf4 \cb1 \strokec4 \
\cb3 AssertEquality typeOfY typeof\cf6 \strokec6 <\cf4 \strokec4 string\cf6 \strokec6 >\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 (* You don't usually need to provide explicit type annotations\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 types for local varaibles, but type annotations can come in\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 handy in other contexts as you'll see later. *)\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- floats and ints -----------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 (* Depending on your background, you may be surprised to learn that\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 in F#, integers and floating point numbers are different types.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 In other words, the following is true. *)\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  a \cf6 \strokec6 =\cf4 \strokec4  \cf8 \strokec8 20\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  typeOfA \cf6 \strokec6 =\cf4 \strokec4  a\cf6 \strokec6 .\cf4 \strokec4 GetType\cf6 \strokec6 ()\cf4 \cb1 \strokec4 \
\
\cf5 \cb3 \strokec5 let\cf4 \strokec4  b \cf6 \strokec6 =\cf4 \strokec4  \cf8 \strokec8 20.0\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  typeOfB \cf6 \strokec6 =\cf4 \strokec4  b\cf6 \strokec6 .\cf4 \strokec4 GetType\cf6 \strokec6 ()\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //you don't need to modify these\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality typeOfA typeof\cf6 \strokec6 <\cf4 \strokec4 int\cf6 \strokec6 >\cf4 \cb1 \strokec4 \
\cb3 AssertEquality typeOfB typeof\cf6 \strokec6 <\cf4 \strokec4 float\cf6 \strokec6 >\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //If you're coming from another .NET language, float is F# slang for\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //the double type.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- modifying the value of variables ------------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  \cf5 \strokec5 mutable\cf4 \strokec4  c \cf6 \strokec6 =\cf4 \strokec4  \cf8 \strokec8 100\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 c \cf6 \strokec6 <-\cf4 \strokec4  \cf8 \strokec8 200\cf4 \cb1 \strokec4 \
\
\cb3 AssertEquality c \cf8 \strokec8 200\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // ---- you can't modify a value if it isn't mutable ------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  e \cf6 \strokec6 =\cf4 \strokec4  \cf8 \strokec8 50\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //What happens if you try to uncomment and run the following line of code?\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //(look at the output in the output window)\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //x <- 100\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 //NOTE: Although you can't modify immutable values, it is\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // possible to reuse the name of a value in some cases\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // using "shadowing".\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  d \cf6 \strokec6 =\cf4 \strokec4  \cf8 \strokec8 100\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality e \cf8 \strokec8 50\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // About Functions\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Now that you've seen how to bind a name to a value with let,\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // you'll learn to use the let keyword to create functions.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- creating functions with let -----------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 (* By default, F# is whitespace sensitive. For functions, this\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 means that the last line of a function is its return value,\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 and the body of a function is denoted by indentation. *)\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  add g f \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 g \cf6 \strokec6 +\cf4 \strokec4  f\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  result1 \cf6 \strokec6 =\cf4 \strokec4  add \cf8 \strokec8 2\cf4 \strokec4  \cf8 \strokec8 2\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  result2 \cf6 \strokec6 =\cf4 \strokec4  add \cf8 \strokec8 5\cf4 \strokec4  \cf8 \strokec8 2\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality result1 \cf8 \strokec8 4\cf4 \cb1 \strokec4 \
\cb3 AssertEquality result2 \cf8 \strokec8 7\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // ---- nesting functions ---------------------------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  quadruple x \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  double x \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 x \cf6 \strokec6 *\cf4 \strokec4  \cf8 \strokec8 2\cf4 \cb1 \strokec4 \
\
\cb3 double\cf6 \strokec6 (\cf4 \strokec4 double\cf6 \strokec6 (\cf4 \strokec4 x\cf6 \strokec6 ))\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  result \cf6 \strokec6 =\cf4 \strokec4  quadruple \cf8 \strokec8 4\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality result \cf8 \strokec8 16\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- adding type annotations ---------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 (* Sometimes you need to help F#'s type inference system out with\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 an explicit type annotation *)\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  sayItLikeAnAuctioneer \cf6 \strokec6 (\cf4 \strokec4 text\cf6 \strokec6 :\cf4 \strokec4 string\cf6 \strokec6 )\cf4 \strokec4  \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 text\cf6 \strokec6 .\cf4 \strokec4 Replace\cf6 \strokec6 (\cf7 \strokec7 " "\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 ""\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  auctioneered \cf6 \strokec6 =\cf4 \strokec4  sayItLikeAnAuctioneer \cf7 \strokec7 "going once going twice sold to the lady in red"\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality auctioneered \cf7 \strokec7 "goingoncegoingtwicesoldtotheladyinred"\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //TRY IT: What happens if you remove the type annotation on text?\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- variables in the parent scope can be accessed -----------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  suffix \cf6 \strokec6 =\cf4 \strokec4  \cf7 \strokec7 "!!!"\cf4 \cb1 \strokec4 \
\
\cf5 \cb3 \strokec5 let\cf4 \strokec4  caffinate \cf6 \strokec6 (\cf4 \strokec4 text\cf6 \strokec6 :\cf4 \strokec4 string\cf6 \strokec6 )\cf4 \strokec4  \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  exclaimed \cf6 \strokec6 =\cf4 \strokec4  text \cf6 \strokec6 +\cf4 \strokec4  suffix\cb1 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  yelled \cf6 \strokec6 =\cf4 \strokec4  exclaimed\cf6 \strokec6 .\cf4 \strokec4 ToUpper\cf6 \strokec6 ()\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 yelled\cf6 \strokec6 .\cf4 \strokec4 Trim\cf6 \strokec6 ()\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  caffinatedReply \cf6 \strokec6 =\cf4 \strokec4  caffinate \cf7 \strokec7 "hello there"\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality caffinatedReply \cf7 \strokec7 "HELLO THERE!!!"\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 (* NOTE: Accessing the suffix variable in the nested caffinate function\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 is known as a closure.\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 See http://en.wikipedia.org/wiki/Closure_(computer_science)\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 for more about about closure. *)\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // About the Order of Evaluation\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Sometimes you'll need to be explicit about the order in which\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // functions are evaluated. F# offers a couple mechanisms for\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // doing this.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- using parenthesis to control the order of operation -----\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  add1 x y \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 x \cf6 \strokec6 +\cf4 \strokec4  y\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  result_1 \cf6 \strokec6 =\cf4 \strokec4  add \cf6 \strokec6 (\cf4 \strokec4 add \cf8 \strokec8 5\cf4 \strokec4  \cf8 \strokec8 8\cf6 \strokec6 )\cf4 \strokec4  \cf6 \strokec6 (\cf4 \strokec4 add \cf8 \strokec8 1\cf4 \strokec4  \cf8 \strokec8 1\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality result_1 \cf8 \strokec8 15\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 (* TRY IT: What happens if you remove the parensthesis?*)\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- the backward pipe operator can also help with grouping --\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  add2 x y \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 x \cf6 \strokec6 +\cf4 \strokec4  y\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  double x \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 x \cf6 \strokec6 *\cf4 \strokec4  \cf8 \strokec8 2\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  result_2 \cf6 \strokec6 =\cf4 \strokec4  double \cf6 \strokec6 <|\cf4 \strokec4  add \cf8 \strokec8 5\cf4 \strokec4  \cf8 \strokec8 8\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality result_2 \cf8 \strokec8 26\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // About Unit\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // The unit type is a special type that represents the lack of\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // a value. It's similar to void in other languages, but unit\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // is actually considered to be a type in F#.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- unit is used when there is no return value --------------\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  sendData data \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //...pretend we are sending the data to the server...\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 \strokec6 ()\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  x1 \cf6 \strokec6 =\cf4 \strokec4  sendData \cf7 \strokec7 "data"\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality x1 \cf6 \strokec6 ()\cf4 \strokec4  \cf2 \strokec2 //Don't overthink this\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- parameterless fucntions take unit as their argument -----\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  sayHello\cf6 \strokec6 ()\cf4 \strokec4  \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 \strokec7 "hello"\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  result3 \cf6 \strokec6 =\cf4 \strokec4  sayHello\cf6 \strokec6 ()\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality result3 \cf7 \strokec7 "Hello"\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Tuples\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Tuples are used to easily group together values in F#. They're\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // another fundamental construct of the language.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- creating tuples -----\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  items1 \cf6 \strokec6 =\cf4 \strokec4  \cf6 \strokec6 (\cf7 \strokec7 "apple"\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 "dog"\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality items1 \cf6 \strokec6 (\cf7 \strokec7 "apple"\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 "dog"\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- accessing tuple elements --------------------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  items2 \cf6 \strokec6 =\cf4 \strokec4  \cf6 \strokec6 (\cf7 \strokec7 "apple"\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 "dog"\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\cf5 \cb3 \strokec5 let\cf4 \strokec4  fruit1 \cf6 \strokec6 =\cf4 \strokec4  fst items2\cb1 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  animal1 \cf6 \strokec6 =\cf4 \strokec4  snd items2\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality fruit1 \cf7 \strokec7 "apple"\cf4 \cb1 \strokec4 \
\cb3 AssertEquality animal1 \cf7 \strokec7 "dog"\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- accessing tuple elements with pattern matching ----------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 (* fst and snd are useful in some situations, but they only work with\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 tuples containing two elements. It's usually better to use a\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 technique called pattern matching to access the values of a tuple.\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 Pattern matching works with tuples of any arity, and it allows you to\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 simultaneously break apart the tuple while assigning a name to each\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 value. Here's an example. *)\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  items3 \cf6 \strokec6 =\cf4 \strokec4  \cf6 \strokec6 (\cf7 \strokec7 "apple"\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 "dog"\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 "Mustang"\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\cf5 \cb3 \strokec5 let\cf4 \strokec4  fruit2\cf6 \strokec6 ,\cf4 \strokec4  animal2\cf6 \strokec6 ,\cf4 \strokec4  car \cf6 \strokec6 =\cf4 \strokec4  items3\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality fruit2 \cf7 \strokec7 "apple"\cf4 \cb1 \strokec4 \
\cb3 AssertEquality animal2 \cf7 \strokec7 "dog"\cf4 \cb1 \strokec4 \
\cb3 AssertEquality car \cf7 \strokec7 "Mustang"\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- ignoring values when pattern matching -------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  items4 \cf6 \strokec6 =\cf4 \strokec4  \cf6 \strokec6 (\cf7 \strokec7 "apple"\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 "dog"\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 "Mustang"\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\cf5 \cb3 \strokec5 let\cf4 \strokec4  _\cf6 \strokec6 ,\cf4 \strokec4  animal3\cf6 \strokec6 ,\cf4 \strokec4  _ \cf6 \strokec6 =\cf4 \strokec4  items4\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality animal3 \cf7 \strokec7 "dog"\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- using tuples to return multiple values from a function --\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  squareAndCube x \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 \strokec6 (\cf4 \strokec4 x \cf6 \strokec6 **\cf4 \strokec4  \cf8 \strokec8 2.0\cf6 \strokec6 ,\cf4 \strokec4  x \cf6 \strokec6 **\cf4 \strokec4  \cf8 \strokec8 3.0\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  squared\cf6 \strokec6 ,\cf4 \strokec4  cubed \cf6 \strokec6 =\cf4 \strokec4  squareAndCube \cf8 \strokec8 3.0\cf4 \cb1 \strokec4 \
\
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality squared \cf8 \strokec8 9.0\cf4 \cb1 \strokec4 \
\cb3 AssertEquality cubed \cf8 \strokec8 27.0\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 (* THINK ABOUT IT: Is there really more than one return value?\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 What type does the squareAndCube function\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 return? *)\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // ---- the truth behind multiple return values ------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  squareAndCube1 x \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 \strokec6 (\cf4 \strokec4 x \cf6 \strokec6 **\cf4 \strokec4  \cf8 \strokec8 2.0\cf6 \strokec6 ,\cf4 \strokec4  x \cf6 \strokec6 **\cf4 \strokec4  \cf8 \strokec8 3.0\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  result5 \cf6 \strokec6 =\cf4 \strokec4  squareAndCube1 \cf8 \strokec8 3.0\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality result5 \cf6 \strokec6 (\cf8 \strokec8 9.0\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 27.0\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Branching\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Branching is used to tell a program to conditionally perform\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // an operation. It's another fundamental part of F#.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- basic if statements -------------------------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  isEven x \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 if\cf4 \strokec4  x \cf6 \strokec6 %\cf4 \strokec4  \cf8 \strokec8 2\cf4 \strokec4  \cf6 \strokec6 =\cf4 \strokec4  \cf8 \strokec8 0\cf4 \strokec4  \cf5 \strokec5 then\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 \strokec7 "it's even!"\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 else\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 \strokec7 "it's odd!"\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  result6 \cf6 \strokec6 =\cf4 \strokec4  isEven \cf8 \strokec8 2\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality result6 \cf7 \strokec7 "it's even!"\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- if statements return values -----------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 (* In languages like C++, Java, and C# if statements do not yield\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 results; they can only cause side effects. If statements in F#\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 return values due to F#'s functional programming roots. *)\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  result7 \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 if\cf4 \strokec4  \cf8 \strokec8 2\cf4 \strokec4  \cf6 \strokec6 =\cf4 \strokec4  \cf8 \strokec8 3\cf4 \strokec4  \cf5 \strokec5 then\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 \strokec7 "something is REALLY wrong"\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 else\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf7 \cb3 \strokec7 "math is workng!"\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality result7 \cf7 \strokec7 "math is workng!"\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // ---- branching with pattern matching -------------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  isApple x \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 match\cf4 \strokec4  x \cf5 \strokec5 with\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 \strokec6 |\cf4 \strokec4  \cf7 \strokec7 "apple"\cf4 \strokec4  \cf6 \strokec6 ->\cf4 \strokec4  \cf5 \strokec5 true\cf4 \cb1 \strokec4 \
\cf6 \cb3 \strokec6 |\cf4 \strokec4  _ \cf6 \strokec6 ->\cf4 \strokec4  \cf5 \strokec5 false\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  result9 \cf6 \strokec6 =\cf4 \strokec4  isApple \cf7 \strokec7 "apple"\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  result8 \cf6 \strokec6 =\cf4 \strokec4  isApple \cf7 \strokec7 ""\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality result9 \cf5 \strokec5 true\cf4 \cb1 \strokec4 \
\cb3 AssertEquality result8 \cf5 \strokec5 false\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- using tuples with if statements quickly becomes clumsy --\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  getDinner x \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  name\cf6 \strokec6 ,\cf4 \strokec4  foodChoice \cf6 \strokec6 =\cf4 \strokec4  x\cb1 \
\
\cf5 \cb3 \strokec5 if\cf4 \strokec4  foodChoice \cf6 \strokec6 =\cf4 \strokec4  \cf7 \strokec7 "veggies"\cf4 \strokec4  \cf6 \strokec6 ||\cf4 \strokec4  foodChoice \cf6 \strokec6 =\cf7 \strokec7 "fish"\cf4 \strokec4  \cf6 \strokec6 ||\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 foodChoice \cf6 \strokec6 =\cf4 \strokec4  \cf7 \strokec7 "chicken"\cf4 \strokec4  \cf5 \strokec5 then\cf4 \cb1 \strokec4 \
\cb3 sprintf \cf7 \strokec7 "%s doesn't want red meat"\cf4 \strokec4  name\cb1 \
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 else\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 sprintf \cf7 \strokec7 "%s wants 'em some %s"\cf4 \strokec4  name foodChoice\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  person1 \cf6 \strokec6 =\cf4 \strokec4  \cf6 \strokec6 (\cf7 \strokec7 "Chris"\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 "steak"\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  person2 \cf6 \strokec6 =\cf4 \strokec4  \cf6 \strokec6 (\cf7 \strokec7 "Dave"\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 "veggies"\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality \cf6 \strokec6 (\cf4 \strokec4 getDinner person1\cf6 \strokec6 )\cf4 \strokec4  \cf7 \strokec7 "Chris wants 'em some steak"\cf4 \cb1 \strokec4 \
\cb3 AssertEquality \cf6 \strokec6 (\cf4 \strokec4 getDinner person2\cf6 \strokec6 )\cf4 \strokec4  \cf7 \strokec7 "Dave doesn't want red meat"\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- pattern matching with tuples is much nicer --------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  getDinner1 x \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 match\cf4 \strokec4  x \cf5 \strokec5 with\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 \strokec6 |\cf4 \strokec4  \cf6 \strokec6 (\cf4 \strokec4 name\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 "veggies"\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cf6 \cb3 \strokec6 |\cf4 \strokec4  \cf6 \strokec6 (\cf4 \strokec4 name\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 "fish"\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cf6 \cb3 \strokec6 |\cf4 \strokec4  \cf6 \strokec6 (\cf4 \strokec4 name\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 "chicken"\cf6 \strokec6 )\cf4 \strokec4  \cf6 \strokec6 ->\cf4 \strokec4  sprintf \cf7 \strokec7 "%s doesn't want red meat"\cf4 \strokec4  name\cb1 \
\cf6 \cb3 \strokec6 |\cf4 \strokec4  \cf6 \strokec6 (\cf4 \strokec4 name\cf6 \strokec6 ,\cf4 \strokec4  foodChoice\cf6 \strokec6 )\cf4 \strokec4  \cf6 \strokec6 ->\cf4 \strokec4  sprintf \cf7 \strokec7 "%s wants 'em some %s"\cf4 \strokec4  name foodChoice\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  person_1 \cf6 \strokec6 =\cf4 \strokec4  \cf6 \strokec6 (\cf7 \strokec7 "Bob"\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 "fish"\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  person_2 \cf6 \strokec6 =\cf4 \strokec4  \cf6 \strokec6 (\cf7 \strokec7 "Sally"\cf6 \strokec6 ,\cf4 \strokec4  \cf7 \strokec7 "Burger"\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality \cf6 \strokec6 (\cf4 \strokec4 getDinner1 person_1\cf6 \strokec6 )\cf4 \strokec4  \cf7 \strokec7 "Bob doesn't want red meat"\cf4 \cb1 \strokec4 \
\cb3 AssertEquality \cf6 \strokec6 (\cf4 \strokec4 getDinner1 person_2\cf6 \strokec6 )\cf4 \strokec4  \cf7 \strokec7 "Sally wants 'em some Burger"\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // About Lists\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Lists are important building blocks that you'll use frequently\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // in F# programming. They are used to group arbitrarily large\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // sequences of values. It's very common to store values in a\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // list and perform operations across each value in the\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // list.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- creating lists ------------------------------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  list \cf6 \strokec6 =\cf4 \strokec4  \cf6 \strokec6 [\cf7 \strokec7 "apple"\cf6 \strokec6 ;\cf4 \strokec4  \cf7 \strokec7 "pear"\cf6 \strokec6 ;\cf4 \strokec4  \cf7 \strokec7 "grape"\cf6 \strokec6 ;\cf4 \strokec4  \cf7 \strokec7 "peach"\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //Note: The list data type in F# is a singly linked list,\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // so indexing elements is O(n).\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality list\cf6 \strokec6 .\cf4 \strokec4 Head \cf7 \strokec7 "apple"\cf4 \cb1 \strokec4 \
\cb3 AssertEquality list\cf6 \strokec6 .\cf4 \strokec4 Tail \cf6 \strokec6 [\cf7 \strokec7 "pear"\cf6 \strokec6 ;\cf4 \strokec4  \cf7 \strokec7 "grape"\cf6 \strokec6 ;\cf4 \strokec4  \cf7 \strokec7 "peach"\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\cb3 AssertEquality list\cf6 \strokec6 .\cf4 \strokec4 Length \cf8 \strokec8 4\cf4 \cb1 \strokec4 \
\
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 (* .NET developers coming from other languages may be surprised\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 that F#'s list type is not the same as the base class library's\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 List<T>. In other words, the following assertion is true *)\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  dotNetList \cf6 \strokec6 =\cf4 \strokec4  \cf5 \strokec5 new\cf4 \strokec4  List\cf6 \strokec6 <\cf4 \strokec4 string\cf6 \strokec6 >()\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //you don't need to modify the following line\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertInequality \cf6 \strokec6 (\cf4 \strokec4 list\cf6 \strokec6 .\cf4 \strokec4 GetType\cf6 \strokec6 ())\cf4 \strokec4  \cf6 \strokec6 (\cf4 \strokec4 dotNetList\cf6 \strokec6 .\cf4 \strokec4 GetType\cf6 \strokec6 ())\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // ---- building new lists---------------------------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  first \cf6 \strokec6 =\cf4 \strokec4  \cf6 \strokec6 [\cf7 \strokec7 "grape"\cf6 \strokec6 ;\cf4 \strokec4  \cf7 \strokec7 "peach"\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  second \cf6 \strokec6 =\cf4 \strokec4  \cf7 \strokec7 "pear"\cf4 \strokec4  \cf6 \strokec6 ::\cf4 \strokec4  first\cb1 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  third \cf6 \strokec6 =\cf4 \strokec4  \cf7 \strokec7 "apple"\cf4 \strokec4  \cf6 \strokec6 ::\cf4 \strokec4  second\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //Note: "::" is known as "cons"\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality \cf6 \strokec6 [\cf7 \strokec7 "apple"\cf6 \strokec6 ;\cf4 \strokec4  \cf7 \strokec7 "pear"\cf6 \strokec6 ;\cf4 \strokec4  \cf7 \strokec7 "grape"\cf6 \strokec6 ;\cf4 \strokec4  \cf7 \strokec7 "peach"\cf6 \strokec6 ]\cf4 \strokec4  third\cb1 \
\cb3 AssertEquality second \cf6 \strokec6 [\cf7 \strokec7 "pear"\cf6 \strokec6 ;\cf4 \strokec4  \cf7 \strokec7 "grape"\cf6 \strokec6 ;\cf4 \strokec4  \cf7 \strokec7 "peach"\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\cb3 AssertEquality first \cf6 \strokec6 [\cf7 \strokec7 "grape"\cf6 \strokec6 ;\cf4 \strokec4  \cf7 \strokec7 "peach"\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //What happens if you uncomment the following?\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 //first.Head <- "apple"\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //first.Tail <- ["peach"; "pear"]\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 //THINK ABOUT IT: Can you change the contents of a list once it\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // has been created?\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- concatenating lists -------------------------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  first \cf6 \strokec6 =\cf4 \strokec4  \cf6 \strokec6 [\cf7 \strokec7 "apple"\cf6 \strokec6 ;\cf4 \strokec4  \cf7 \strokec7 "pear"\cf6 \strokec6 ;\cf4 \strokec4  \cf7 \strokec7 "grape"\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  second \cf6 \strokec6 =\cf4 \strokec4  first @ \cf6 \strokec6 [\cf7 \strokec7 "peach"\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality first \cf6 \strokec6 [\cf7 \strokec7 "apple"\cf6 \strokec6 ;\cf4 \strokec4  \cf7 \strokec7 "pear"\cf6 \strokec6 ;\cf4 \strokec4  \cf7 \strokec7 "grape"\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\cb3 AssertEquality second \cf6 \strokec6 [\cf7 \strokec7 "apple"\cf6 \strokec6 ;\cf4 \strokec4  \cf7 \strokec7 "pear"\cf6 \strokec6 ;\cf4 \strokec4  \cf7 \strokec7 "grape"\cf6 \strokec6 ;\cf4 \strokec4  \cf7 \strokec7 "peach"\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 (* THINK ABOUT IT: In general, what performs better for building lists,\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 :: or @? Why?\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 Hint: There is no way to modify "first" in the above example. It's\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 immutable. With that in mind, what does the @ function have to do in\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 order to append ["peach"] to "first" to create "second"? *)\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // ---- creating lists with a range------------------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  list \cf6 \strokec6 =\cf4 \strokec4  \cf6 \strokec6 [\cf8 \strokec8 0\cf6 \strokec6 ..\cf8 \strokec8 4\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality list\cf6 \strokec6 .\cf4 \strokec4 Head \cf8 \strokec8 0\cf4 \cb1 \strokec4 \
\cb3 AssertEquality list\cf6 \strokec6 .\cf4 \strokec4 Tail \cf6 \strokec6 [\cf8 \strokec8 1\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 2\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 3\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 4\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // ---- creating lists with comprehensions-----------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  list \cf6 \strokec6 =\cf4 \strokec4  \cf6 \strokec6 [\cf5 \strokec5 for\cf4 \strokec4  i \cf5 \strokec5 in\cf4 \strokec4  \cf8 \strokec8 0\cf6 \strokec6 ..\cf8 \strokec8 4\cf4 \strokec4  \cf5 \strokec5 do\cf4 \strokec4  \cf5 \strokec5 yield\cf4 \strokec4  i \cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality list \cf6 \strokec6 [\cf8 \strokec8 0\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 1\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 2\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 3\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 4\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // ---- comprehensions with conditions --------------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  list \cf6 \strokec6 =\cf4 \strokec4  \cf6 \strokec6 [\cf5 \strokec5 for\cf4 \strokec4  i \cf5 \strokec5 in\cf4 \strokec4  \cf8 \strokec8 0\cf6 \strokec6 ..\cf8 \strokec8 10\cf4 \strokec4  \cf5 \strokec5 do\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 if\cf4 \strokec4  i \cf6 \strokec6 %\cf4 \strokec4  \cf8 \strokec8 2\cf4 \strokec4  \cf6 \strokec6 =\cf4 \strokec4  \cf8 \strokec8 0\cf4 \strokec4  \cf5 \strokec5 then\cf4 \strokec4  \cf5 \strokec5 yield\cf4 \strokec4  i \cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality list \cf6 \strokec6 [\cf8 \strokec8 0\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 2\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 4\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 6\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 8\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 10\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // ---- transforming lists with map -----------------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  square x \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 x \cf6 \strokec6 *\cf4 \strokec4  x\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  original \cf6 \strokec6 =\cf4 \strokec4  \cf6 \strokec6 [\cf8 \strokec8 0\cf6 \strokec6 ..\cf8 \strokec8 5\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  result \cf6 \strokec6 =\cf4 \strokec4  List\cf6 \strokec6 .\cf4 \strokec4 map square original\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality original \cf6 \strokec6 [\cf8 \strokec8 0\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 1\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 2\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 3\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 4\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 5\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\cb3 AssertEquality result \cf6 \strokec6 [\cf8 \strokec8 0\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 1\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 4\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 9\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 16\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 25\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- filtering lists with where ------------------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  isEven x \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 x \cf6 \strokec6 %\cf4 \strokec4  \cf8 \strokec8 2\cf4 \strokec4  \cf6 \strokec6 =\cf4 \strokec4  \cf8 \strokec8 0\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  original \cf6 \strokec6 =\cf4 \strokec4  \cf6 \strokec6 [\cf8 \strokec8 0\cf6 \strokec6 ..\cf8 \strokec8 5\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  result \cf6 \strokec6 =\cf4 \strokec4  List\cf6 \strokec6 .\cf4 \strokec4 filter isEven original\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality original \cf6 \strokec6 [\cf8 \strokec8 0\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 1\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 2\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 3\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 4\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 5\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\cb3 AssertEquality result \cf6 \strokec6 [\cf8 \strokec8 0\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 2\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 4\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- dividing lists with partition ---------------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  isOdd x \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 not\cf6 \strokec6 (\cf4 \strokec4 x \cf6 \strokec6 %\cf4 \strokec4  \cf8 \strokec8 2\cf4 \strokec4  \cf6 \strokec6 =\cf4 \strokec4  \cf8 \strokec8 0\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\cf5 \cb3 \strokec5 let\cf4 \strokec4  original \cf6 \strokec6 =\cf4 \strokec4  \cf6 \strokec6 [\cf8 \strokec8 0\cf6 \strokec6 ..\cf8 \strokec8 5\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  result1\cf6 \strokec6 ,\cf4 \strokec4  result2 \cf6 \strokec6 =\cf4 \strokec4  List\cf6 \strokec6 .\cf4 \strokec4 partition isOdd original\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality result1 \cf6 \strokec6 [\cf8 \strokec8 1\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 3\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 5\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\cb3 AssertEquality result2 \cf6 \strokec6 [\cf8 \strokec8 0\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 2\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 4\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 (* Note: There are many other useful methods in the List module. Check them\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 via intellisense in Visual Studio by typing '.' after List, or online at\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 http://msdn.microsoft.com/en-us/library/ee353738.aspx *)\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Pipelining\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // The forward pipe operator is one of the most commonly used\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // symbols in F# programming. You can use it combine operations\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // on lists and other data structures in a readable way.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\
\cf2 \cb3 \strokec2 // ---- square even numbers with separate statementes -----------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  square x \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 x \cf6 \strokec6 *\cf4 \strokec4  x\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  isEven x \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 x \cf6 \strokec6 %\cf4 \strokec4  \cf8 \strokec8 2\cf4 \strokec4  \cf6 \strokec6 =\cf4 \strokec4  \cf8 \strokec8 0\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 (* One way to combine operations is by using separate statements.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 However, this is can be clumsy since you have to name each result. *)\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  numbers \cf6 \strokec6 =\cf4 \strokec4  \cf6 \strokec6 [\cf8 \strokec8 0\cf6 \strokec6 ..\cf8 \strokec8 5\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\
\cf5 \cb3 \strokec5 let\cf4 \strokec4  evens \cf6 \strokec6 =\cf4 \strokec4  List\cf6 \strokec6 .\cf4 \strokec4 filter isEven numbers\cb1 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  result \cf6 \strokec6 =\cf4 \strokec4  List\cf6 \strokec6 .\cf4 \strokec4 map square evens\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality result \cf6 \strokec6 [\cf8 \strokec8 0\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 4\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 16\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // ---- square even numbers with parens -------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 (* You can avoid this problem by using parens to pass the result of one\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 funciton to another. This can be difficult to read since you have to\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 start from the innermost function and work your way out. *)\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  numbers \cf6 \strokec6 =\cf4 \strokec4  \cf6 \strokec6 [\cf8 \strokec8 0\cf6 \strokec6 ..\cf8 \strokec8 5\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\
\cf5 \cb3 \strokec5 let\cf4 \strokec4  result \cf6 \strokec6 =\cf4 \strokec4  List\cf6 \strokec6 .\cf4 \strokec4 map square \cf6 \strokec6 (\cf4 \strokec4 List\cf6 \strokec6 .\cf4 \strokec4 filter isEven numbers\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality result \cf6 \strokec6 [\cf8 \strokec8 0\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 4\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 16\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // ---- square even numbers with the pipeline operator ---------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 (* In F#, you can use the pipeline operator to get the benefit of the\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 parens style with the readablity of the statement style. *)\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  result \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 \strokec6 [\cf8 \strokec8 0\cf6 \strokec6 ..\cf8 \strokec8 5\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\cf6 \cb3 \strokec6 |>\cf4 \strokec4  List\cf6 \strokec6 .\cf4 \strokec4 filter isEven\cb1 \
\cf6 \cb3 \strokec6 |>\cf4 \strokec4  List\cf6 \strokec6 .\cf4 \strokec4 map square\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality result \cf6 \strokec6 [\cf8 \strokec8 0\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 4\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 16\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // ---- how the pipe operator is defined ------------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  \cf6 \strokec6 (|>)\cf4 \strokec4  x y \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 y x\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  result \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 \strokec6 [\cf8 \strokec8 0\cf6 \strokec6 ..\cf8 \strokec8 5\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\cf6 \cb3 \strokec6 |>\cf4 \strokec4  List\cf6 \strokec6 .\cf4 \strokec4 filter isEven\cb1 \
\cf6 \cb3 \strokec6 |>\cf4 \strokec4  List\cf6 \strokec6 .\cf4 \strokec4 map square\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality result \cf6 \strokec6 [\cf8 \strokec8 0\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 4\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 16\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------//---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Arrays\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Like lists, arrays are another basic container type in F#.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- creating arrays -----------------------------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  fruits \cf6 \strokec6 =\cf4 \strokec4  \cf6 \strokec6 [|\cf4 \strokec4  \cf7 \strokec7 "apple"\cf6 \strokec6 ;\cf4 \strokec4  \cf7 \strokec7 "pear"\cf6 \strokec6 ;\cf4 \strokec4  \cf7 \strokec7 "peach"\cf6 \strokec6 |]\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality fruits\cf6 \strokec6 .[\cf8 \strokec8 0\cf6 \strokec6 ]\cf4 \strokec4  \cf7 \strokec7 "apple"\cf4 \cb1 \strokec4 \
\cb3 AssertEquality fruits\cf6 \strokec6 .[\cf8 \strokec8 1\cf6 \strokec6 ]\cf4 \strokec4  \cf7 \strokec7 "pear"\cf4 \cb1 \strokec4 \
\cb3 AssertEquality fruits\cf6 \strokec6 .[\cf8 \strokec8 2\cf6 \strokec6 ]\cf4 \strokec4  \cf7 \strokec7 "peach"\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- arrays are mutable --------------------------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  fruits \cf6 \strokec6 =\cf4 \strokec4  \cf6 \strokec6 [|\cf4 \strokec4  \cf7 \strokec7 "apple"\cf6 \strokec6 ;\cf4 \strokec4  \cf7 \strokec7 "pear"\cf4 \strokec4  \cf6 \strokec6 |]\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 fruits\cf6 \strokec6 .[\cf8 \strokec8 1\cf6 \strokec6 ]\cf4 \strokec4  \cf6 \strokec6 <-\cf4 \strokec4  \cf7 \strokec7 "peach"\cf4 \cb1 \strokec4 \
\
\cb3 AssertEquality fruits \cf6 \strokec6 [|\cf4 \strokec4  \cf7 \strokec7 "apple"\cf6 \strokec6 ;\cf4 \strokec4  \cf7 \strokec7 "peach"\cf4 \strokec4  \cf6 \strokec6 |]\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- you can create arrays with comprehensions ---------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  numbers \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 \strokec6 [|\cf4 \strokec4  \cf5 \strokec5 for\cf4 \strokec4  i \cf5 \strokec5 in\cf4 \strokec4  \cf8 \strokec8 0\cf6 \strokec6 ..\cf8 \strokec8 10\cf4 \strokec4  \cf5 \strokec5 do\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 if\cf4 \strokec4  i \cf6 \strokec6 %\cf4 \strokec4  \cf8 \strokec8 2\cf4 \strokec4  \cf6 \strokec6 =\cf4 \strokec4  \cf8 \strokec8 0\cf4 \strokec4  \cf5 \strokec5 then\cf4 \strokec4  \cf5 \strokec5 yield\cf4 \strokec4  i \cf6 \strokec6 |]\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality numbers \cf6 \strokec6 [|\cf4 \strokec4  \cf8 \strokec8 0\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 2\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 4\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 6\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 8\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 10\cf4 \strokec4  \cf6 \strokec6 |]\cf4 \cb1 \strokec4 \
\
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- you can also perform operations on arrays ---------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  cube x \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 x \cf6 \strokec6 *\cf4 \strokec4  x \cf6 \strokec6 *\cf4 \strokec4  x\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  original \cf6 \strokec6 =\cf4 \strokec4  \cf6 \strokec6 [|\cf4 \strokec4  \cf8 \strokec8 0\cf6 \strokec6 ..\cf8 \strokec8 5\cf4 \strokec4  \cf6 \strokec6 |]\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  result \cf6 \strokec6 =\cf4 \strokec4  Array\cf6 \strokec6 .\cf4 \strokec4 map cube original\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality original \cf6 \strokec6 [|\cf4 \strokec4  \cf8 \strokec8 0\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 1\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 2\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 3\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 4\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 5\cf4 \strokec4  \cf6 \strokec6 |]\cf4 \cb1 \strokec4 \
\cb3 AssertEquality result \cf6 \strokec6 [|\cf4 \strokec4  \cf8 \strokec8 0\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 1\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 8\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 27\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 64\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 125\cf4 \strokec4  \cf6 \strokec6 |]\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 (* See more Array methods at\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 http://msdn.microsoft.com/en-us/library/ee370273.aspx *)\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // .NET Collections\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Since F# is bulit for seamless interop with other CLR\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // languages, you can use all of the basic .NET collections types\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // you're already familiar with if you're a C# or VB programmer.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- creating .NET lists -------------------------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  fruits \cf6 \strokec6 =\cf4 \strokec4  \cf5 \strokec5 new\cf4 \strokec4  List\cf6 \strokec6 <\cf4 \strokec4 string\cf6 \strokec6 >()\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 fruits\cf6 \strokec6 .\cf4 \strokec4 Add\cf6 \strokec6 (\cf7 \strokec7 "apple"\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3 fruits\cf6 \strokec6 .\cf4 \strokec4 Add\cf6 \strokec6 (\cf7 \strokec7 "pear"\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\cb3 AssertEquality fruits\cf6 \strokec6 .[\cf8 \strokec8 0\cf6 \strokec6 ]\cf4 \strokec4  \cf7 \strokec7 "apple"\cf4 \cb1 \strokec4 \
\cb3 AssertEquality fruits\cf6 \strokec6 .[\cf8 \strokec8 1\cf6 \strokec6 ]\cf4 \strokec4  \cf7 \strokec7 "pear"\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- creating .NET dictionaries ------------------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  addressBook \cf6 \strokec6 =\cf4 \strokec4  \cf5 \strokec5 new\cf4 \strokec4  Dictionary\cf6 \strokec6 <\cf4 \strokec4 string\cf6 \strokec6 ,\cf4 \strokec4  string\cf6 \strokec6 >()\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 addressBook\cf6 \strokec6 .[\cf7 \strokec7 "Chris"\cf6 \strokec6 ]\cf4 \strokec4  \cf6 \strokec6 <-\cf4 \strokec4  \cf7 \strokec7 "Ann Arbor"\cf4 \cb1 \strokec4 \
\cb3 addressBook\cf6 \strokec6 .[\cf7 \strokec7 "SkillsMatter"\cf6 \strokec6 ]\cf4 \strokec4  \cf6 \strokec6 <-\cf4 \strokec4  \cf7 \strokec7 "London"\cf4 \cb1 \strokec4 \
\
\cb3 AssertEquality addressBook\cf6 \strokec6 .[\cf7 \strokec7 "Chris"\cf6 \strokec6 ]\cf4 \strokec4  \cf7 \strokec7 "Ann Arbor"\cf4 \cb1 \strokec4 \
\cb3 AssertEquality addressBook\cf6 \strokec6 .[\cf7 \strokec7 "SkillsMatter"\cf6 \strokec6 ]\cf4 \strokec4  \cf7 \strokec7 "London"\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- you can use combinators with .NET types ----------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  addressBook \cf6 \strokec6 =\cf4 \strokec4  \cf5 \strokec5 new\cf4 \strokec4  Dictionary\cf6 \strokec6 <\cf4 \strokec4 string\cf6 \strokec6 ,\cf4 \strokec4  string\cf6 \strokec6 >()\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 addressBook\cf6 \strokec6 .[\cf7 \strokec7 "Chris"\cf6 \strokec6 ]\cf4 \strokec4  \cf6 \strokec6 <-\cf4 \strokec4  \cf7 \strokec7 "Ann Arbor"\cf4 \cb1 \strokec4 \
\cb3 addressBook\cf6 \strokec6 .[\cf7 \strokec7 "SkillsMatter"\cf6 \strokec6 ]\cf4 \strokec4  \cf6 \strokec6 <-\cf4 \strokec4  \cf7 \strokec7 "London"\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  verboseBook \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 addressBook\cb1 \
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 \strokec6 |>\cf4 \strokec4  Seq\cf6 \strokec6 .\cf4 \strokec4 map \cf6 \strokec6 (\cf5 \strokec5 fun\cf4 \strokec4  kvp \cf6 \strokec6 ->\cf4 \strokec4  sprintf \cf7 \strokec7 "Name: %s - City: %s"\cf4 \strokec4  kvp\cf6 \strokec6 .\cf4 \strokec4 Key kvp\cf6 \strokec6 .\cf4 \strokec4 Value\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cf6 \cb3 \strokec6 |>\cf4 \strokec4  Seq\cf6 \strokec6 .\cf4 \strokec4 toArray\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //NOTE: The seq type in F# is an alias for .NET's IEnumerable interface\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Like the List and Array module, the Seq module contains functions\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // that you can combine to perform operations on types implementing\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // seq/IEnumerable. The methods found in these modules are known as\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // combinators\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality verboseBook\cf6 \strokec6 .[\cf8 \strokec8 0\cf6 \strokec6 ]\cf4 \strokec4  \cf7 \strokec7 "Name: Chris - City: Ann Arbor"\cf4 \cb1 \strokec4 \
\cb3 AssertEquality verboseBook\cf6 \strokec6 .[\cf8 \strokec8 1\cf6 \strokec6 ]\cf4 \strokec4  \cf7 \strokec7 "Name: SkillsMatter - City: London"\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- skipping elements ---------------------------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  original \cf6 \strokec6 =\cf4 \strokec4  \cf6 \strokec6 [\cf8 \strokec8 0\cf6 \strokec6 ..\cf8 \strokec8 5\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  result \cf6 \strokec6 =\cf4 \strokec4  Seq\cf6 \strokec6 .\cf4 \strokec4 skip \cf8 \strokec8 2\cf4 \strokec4  original\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality result \cf6 \strokec6 [\cf8 \strokec8 3\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 4\cf6 \strokec6 ;\cf4 \strokec4  \cf8 \strokec8 5\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- finding the max -----------------------------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  values \cf6 \strokec6 =\cf4 \strokec4  \cf5 \strokec5 new\cf4 \strokec4  List\cf6 \strokec6 <\cf4 \strokec4 int\cf6 \strokec6 >()\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 values\cf6 \strokec6 .\cf4 \strokec4 Add\cf6 \strokec6 (\cf8 \strokec8 11\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3 values\cf6 \strokec6 .\cf4 \strokec4 Add\cf6 \strokec6 (\cf8 \strokec8 20\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3 values\cf6 \strokec6 .\cf4 \strokec4 Add\cf6 \strokec6 (\cf8 \strokec8 4\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3 values\cf6 \strokec6 .\cf4 \strokec4 Add\cf6 \strokec6 (\cf8 \strokec8 2\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\cb3 values\cf6 \strokec6 .\cf4 \strokec4 Add\cf6 \strokec6 (\cf8 \strokec8 3\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  result \cf6 \strokec6 =\cf4 \strokec4  Seq\cf6 \strokec6 .\cf4 \strokec4 max values\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality result \cf8 \strokec8 20\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- finding the max using a condition -----------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  getNameLength \cf6 \strokec6 (\cf4 \strokec4 name\cf6 \strokec6 :\cf4 \strokec4 string\cf6 \strokec6 )\cf4 \strokec4  \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 name\cf6 \strokec6 .\cf4 \strokec4 Length\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  names \cf6 \strokec6 =\cf4 \strokec4  \cf6 \strokec6 [|\cf4 \strokec4  \cf7 \strokec7 "Harry"\cf6 \strokec6 ;\cf4 \strokec4  \cf7 \strokec7 "Lloyd"\cf6 \strokec6 ;\cf4 \strokec4  \cf7 \strokec7 "Nicholas"\cf6 \strokec6 ;\cf4 \strokec4  \cf7 \strokec7 "Mary"\cf6 \strokec6 ;\cf4 \strokec4  \cf7 \strokec7 "Joe"\cf6 \strokec6 ;\cf4 \strokec4  \cf6 \strokec6 |]\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  result \cf6 \strokec6 =\cf4 \strokec4  Seq\cf6 \strokec6 .\cf4 \strokec4 maxBy getNameLength names\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality result \cf7 \strokec7 "Nicholas"\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // Looping\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // While it's more common in F# to use the Seq, List, or Array\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // modules to perform looping operations, you can still fall\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // back on traditional imperative looping techniques that you may\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // be more familiar with.\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- looping over a list -------------------------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  values \cf6 \strokec6 =\cf4 \strokec4  \cf6 \strokec6 [\cf8 \strokec8 0\cf6 \strokec6 ..\cf8 \strokec8 10\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\
\cf5 \cb3 \strokec5 let\cf4 \strokec4  \cf5 \strokec5 mutable\cf4 \strokec4  sum \cf6 \strokec6 =\cf4 \strokec4  \cf8 \strokec8 0\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 for\cf4 \strokec4  value \cf5 \strokec5 in\cf4 \strokec4  values \cf5 \strokec5 do\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 sum \cf6 \strokec6 <-\cf4 \strokec4  sum \cf6 \strokec6 +\cf4 \strokec4  value\cb1 \
\
\cb3 AssertEquality sum \cf8 \strokec8 55\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- looping with expressions --------------------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  \cf5 \strokec5 mutable\cf4 \strokec4  sum \cf6 \strokec6 =\cf4 \strokec4  \cf8 \strokec8 0\cf4 \cb1 \strokec4 \
\
\cf5 \cb3 \strokec5 for\cf4 \strokec4  i \cf6 \strokec6 =\cf4 \strokec4  \cf8 \strokec8 1\cf4 \strokec4  \cf5 \strokec5 to\cf4 \strokec4  \cf8 \strokec8 5\cf4 \strokec4  \cf5 \strokec5 do\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 sum \cf6 \strokec6 <-\cf4 \strokec4  sum \cf6 \strokec6 +\cf4 \strokec4  i\cb1 \
\
\cb3 AssertEquality sum \cf8 \strokec8 15\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- looping with while --------------------------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  \cf5 \strokec5 mutable\cf4 \strokec4  sum \cf6 \strokec6 =\cf4 \strokec4  \cf8 \strokec8 1\cf4 \cb1 \strokec4 \
\
\cf5 \cb3 \strokec5 while\cf4 \strokec4  sum \cf6 \strokec6 <\cf4 \strokec4  \cf8 \strokec8 10\cf4 \strokec4  \cf5 \strokec5 do\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 sum \cf6 \strokec6 <-\cf4 \strokec4  sum \cf6 \strokec6 +\cf4 \strokec4  sum\cb1 \
\
\cb3 AssertEquality sum \cf8 \strokec8 16\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 (* NOTE: While these looping constructs can come in handy from time to time,\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 it's often better to use a more functional approach for looping\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 such as the functions you learned about in the List module. *)\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // More About Funtions\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // You've already learned a little about funcitons in F#, but\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // since F# is a functional language, there are more tricks\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 // to learn!\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- defining lambdas ----------------------------------------\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  colors \cf6 \strokec6 =\cf4 \strokec4  \cf6 \strokec6 [\cf7 \strokec7 "maize"\cf6 \strokec6 ;\cf4 \strokec4  \cf7 \strokec7 "blue"\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\
\cf5 \cb3 \strokec5 let\cf4 \strokec4  echo \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 colors\cb1 \
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 \strokec6 |>\cf4 \strokec4  List\cf6 \strokec6 .\cf4 \strokec4 map \cf6 \strokec6 (\cf5 \strokec5 fun\cf4 \strokec4  x \cf6 \strokec6 ->\cf4 \strokec4  x \cf6 \strokec6 +\cf4 \strokec4  \cf7 \strokec7 " "\cf4 \strokec4  \cf6 \strokec6 +\cf4 \strokec4  x\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality echo \cf6 \strokec6 [\cf7 \strokec7 "maize maize"\cf6 \strokec6 ;\cf4 \strokec4  \cf7 \strokec7 "blue blue"\cf6 \strokec6 ]\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 (* The fun keyword allows you to create a function inline without giving\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 it a name. These functions are known as anonymous functions, lambdas,\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 or lambda functions. *)\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- functions that return functions ------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 (* A neat functional programming trick is to create functions that\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 return other functions. This leads to some interesting behaviors. *)\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  add x \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf6 \cb3 \strokec6 (\cf5 \strokec5 fun\cf4 \strokec4  y \cf6 \strokec6 ->\cf4 \strokec4  x \cf6 \strokec6 +\cf4 \strokec4  y\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 (* F#'s lightweight syntax allows you to call both functions as if there\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 was only one *)\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  simpleResult \cf6 \strokec6 =\cf4 \strokec4  add \cf8 \strokec8 2\cf4 \strokec4  \cf8 \strokec8 4\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality simpleResult \cf8 \strokec8 6\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 (* ...but you can also pass only one argument at a time to create\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 residual functions. This technique is known as partial appliction. *)\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  addTen \cf6 \strokec6 =\cf4 \strokec4  add \cf8 \strokec8 10\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  fancyResult \cf6 \strokec6 =\cf4 \strokec4  addTen \cf8 \strokec8 14\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality fancyResult \cf8 \strokec8 24\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //NOTE: Functions written in this style are said to be curried.\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- automatic currying --------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 (* The above technique is common enough that F# actually supports this\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 by default. In other words, functions are automatically curried. *)\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  add x y \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 x \cf6 \strokec6 +\cf4 \strokec4  y\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  addSeven \cf6 \strokec6 =\cf4 \strokec4  add \cf8 \strokec8 7\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  unluckyNumber \cf6 \strokec6 =\cf4 \strokec4  addSeven \cf8 \strokec8 6\cf4 \cb1 \strokec4 \
\cf5 \cb3 \strokec5 let\cf4 \strokec4  luckyNumber \cf6 \strokec6 =\cf4 \strokec4  addSeven \cf8 \strokec8 0\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality unluckyNumber \cf8 \strokec8 13\cf4 \cb1 \strokec4 \
\cb3 AssertEquality luckyNumber \cf8 \strokec8 7\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 // ---- non curried functions -----------------------------------\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 (* You should stick to the auto-curried function syntax most of the\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 time. However, you can also write functions in an uncurried form to\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 make them easier to use from languages like C# where currying is not\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 as commonly used. *)\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  add\cf6 \strokec6 (\cf4 \strokec4 x\cf6 \strokec6 ,\cf4 \strokec4  y\cf6 \strokec6 )\cf4 \strokec4  \cf6 \strokec6 =\cf4 \cb1 \strokec4 \
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 x \cf6 \strokec6 +\cf4 \strokec4  y\cb1 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 (* NOTE: "add 5" will not compile now. You have to pass both arguments\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 at once *)\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf5 \cb3 \strokec5 let\cf4 \strokec4  result \cf6 \strokec6 =\cf4 \strokec4  add\cf6 \strokec6 (\cf8 \strokec8 5\cf6 \strokec6 ,\cf4 \strokec4  \cf8 \strokec8 40\cf6 \strokec6 )\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf4 \cb3 AssertEquality result \cf8 \strokec8 45\cf4 \cb1 \strokec4 \
\
\pard\pardeftab720\partightenfactor0
\cf2 \cb3 \strokec2 (* THINK ABOUT IT: You learned earlier that functions with multiple\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 return values are really just functions that return\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 tuples. Do functions defined in the uncurried form\cf4 \cb1 \strokec4 \
\cf2 \cb3 \strokec2 really accept more than one argument at a time? *)\cf4 \cb1 \strokec4 \
\
\cf2 \cb3 \strokec2 //---------------------------------------------------------------\cf4 \cb1 \strokec4 \
\
\
}