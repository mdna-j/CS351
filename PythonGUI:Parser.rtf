{\rtf1\ansi\ansicpg1252\cocoartf2761
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red195\green123\blue90;\red23\green23\blue26;\red174\green176\blue183;
\red103\green107\blue114;\red89\green158\blue96;\red38\green157\blue169;\red71\green149\blue242;\red160\green0\blue163;
\red128\green63\blue122;\red152\green54\blue29;\red117\green114\blue185;}
{\*\expandedcolortbl;;\csgenericrgb\c76471\c48235\c35294;\csgenericrgb\c9020\c9020\c10196;\csgenericrgb\c68235\c69020\c71765;
\csgenericrgb\c40392\c41961\c44706;\csgenericrgb\c34902\c61961\c37647;\csgenericrgb\c14902\c61569\c66275;\csgenericrgb\c27843\c58431\c94902;\csgenericrgb\c62745\c0\c63922;
\csgenericrgb\c50196\c24706\c47843;\csgenericrgb\c59608\c21176\c11373;\csgenericrgb\c45882\c44706\c72549;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f0\fs26 \cf2 \cb3 import \cf4 re\
\cf2 from \cf4 tkinter \cf2 import \cf4 *\
\
\cf5 # Regular expressions for each token type\
\cf4 token_specs = [\
    (\cf6 'Keyword'\cf4 , \cf6 r'\\b(if|else|int|float)\\b'\cf4 ),        \cf5 # Keywords\
    \cf4 (\cf6 'Operator'\cf4 , \cf6 r'[=+>*]'\cf4 ),                        \cf5 # Operators\
    \cf4 (\cf6 'Separator'\cf4 , \cf6 r'[\\(\\):";]'\cf4 ),                    \cf5 # Separators\
    \cf4 (\cf6 'Float_Literal'\cf4 , \cf6 r'\\b\\d+\\.\\d+\\b'\cf4 ),             \cf5 # Floats\
    \cf4 (\cf6 'Int_Literal'\cf4 , \cf6 r'\\b\\d+\\b'\cf4 ),                    \cf5 # Integers\
    \cf4 (\cf6 'Identifier'\cf4 , \cf6 r'[a-zA-Z][a-zA-Z0-9]*'\cf4 ),        \cf5 # Identifiers\
    \cf4 (\cf6 'String_Literal'\cf4 , \cf6 r'"[^"]*"'\cf4 ),                 \cf5 # Strings\
    \cf4 (\cf6 'Whitespace'\cf4 , \cf6 r'\\s+'\cf4 )                          \cf5 # Whitespace\
\cf4 ]\
\
\cf5 # Combine the token regular expressions\
\cf4 token_regex = \cf6 '|'\cf4 .join(\cf6 f'(?P<\cf2 \{\cf4 pair[\cf7 0\cf4 ]\cf2 \}\cf6 >\cf2 \{\cf4 pair[\cf7 1\cf4 ]\cf2 \}\cf6 )' \cf2 for \cf4 pair \cf2 in \cf4 token_specs)\
\
\cf2 def \cf8 CutOneLineTokens\cf4 (code):\
    \cf5 # List to store <type, token> pairs\
    \cf4 tokens = []\
\
    \cf5 # Tokenize the input code using the regex patterns\
    \cf2 for \cf4 match \cf2 in \cf4 re.finditer(token_regex, code):\
        token_type = match.lastgroup\
        token_value = match.group(token_type)\
\
        \cf2 if \cf4 token_type == \cf6 'Whitespace'\cf4 :\
            \cf2 continue  \cf5 # Skip whitespace\
\
        \cf4 tokens.append(\cf6 f'<\cf2 \{\cf4 token_type\cf2 \}\cf6 , \cf2 \{\cf4 token_value\cf2 \}\cf6 >'\cf4 )\
\
    \cf2 return \cf4 tokens\
\
\cf5 # Parsing Functions\
\cf2 def \cf8 parse_math_expression\cf4 (tokens):\
    \cf5 # Simplified parsing for the math expression using basic BNF\
    \cf4 result = []\
    \cf2 for \cf4 token \cf2 in \cf4 tokens:\
        result.append(\cf6 f"Processing token: \cf2 \{\cf4 token\cf2 \}\cf6 "\cf4 )\
    \cf2 return \cf4 result\
\
\cf2 def \cf8 parse_if_statement\cf4 (tokens):\
    \cf5 # Parsing logic for 'if' statements\
    \cf4 result = []\
    \cf2 if \cf4 tokens[\cf7 0\cf4 ] == \cf6 '<Keyword, if>'\cf4 :\
        result.append(\cf6 "Found 'if' keyword"\cf4 )\
        \cf2 if \cf4 tokens[\cf7 1\cf4 ] == \cf6 '<Separator, (>' \cf2 and \cf4 tokens[\cf7 3\cf4 ] == \cf6 '<Separator, )>'\cf4 :\
            result.append(\cf6 "Found '(' and ')'"\cf4 )\
        \cf2 if \cf4 tokens[\cf7 4\cf4 ] == \cf6 '<Operator, >'\cf4 :\
            result.append(\cf6 "Found '>' operator"\cf4 )\
        \cf2 if \cf4 tokens[\cf7 5\cf4 ] == \cf6 '<Separator, :>'\cf4 :\
            result.append(\cf6 "Found ':'"\cf4 )\
    \cf2 return \cf4 result\
\
\cf2 def \cf8 parse_print_statement\cf4 (tokens):\
    \cf5 # Parsing logic for 'print' statements\
    \cf4 result = []\
    \cf2 if \cf4 tokens[\cf7 0\cf4 ] == \cf6 '<Keyword, print>'\cf4 :\
        result.append(\cf6 "Found 'print' keyword"\cf4 )\
    \cf2 return \cf4 result\
\
\cf5 # GUI Class\
\cf2 class \cf4 LexerGUI:\
    \cf2 def \cf9 __init__\cf4 (\cf10 self\cf4 , root):\
        \cf10 self\cf4 .master = root\
        \cf10 self\cf4 .master.title(\cf6 "Lexer Simulator"\cf4 )\
\
        \cf5 # Enable resizing of the window\
        \cf10 self\cf4 .master.rowconfigure(\cf7 1\cf4 , \cf11 weight\cf4 =\cf7 1\cf4 )  \cf5 # Row 1 (Textboxes) can grow\
        \cf10 self\cf4 .master.columnconfigure(\cf7 0\cf4 , \cf11 weight\cf4 =\cf7 1\cf4 )  \cf5 # Input column grows\
        \cf10 self\cf4 .master.columnconfigure(\cf7 1\cf4 , \cf11 weight\cf4 =\cf7 1\cf4 )  \cf5 # Output column grows\
\
        # Creating labels for input and output\
        \cf10 self\cf4 .input_label = Label(\cf10 self\cf4 .master, \cf11 text\cf4 =\cf6 "Source Code Input"\cf4 )\
        \cf10 self\cf4 .output_label = Label(\cf10 self\cf4 .master, \cf11 text\cf4 =\cf6 "Lexer Output"\cf4 )\
        \cf10 self\cf4 .parser_label = Label(\cf10 self\cf4 .master, \cf11 text\cf4 =\cf6 "Parser Output"\cf4 )\
        \cf10 self\cf4 .line_number_label = Label(\cf10 self\cf4 .master, \cf11 text\cf4 =\cf6 "Current Processing Line: 0"\cf4 )\
\
        \cf5 # Creating Text widgets for multi-line input and output\
        \cf10 self\cf4 .input_text = Text(\cf10 self\cf4 .master, \cf11 height\cf4 =\cf7 20\cf4 , \cf11 width\cf4 =\cf7 40\cf4 )\
        \cf10 self\cf4 .output_text = Text(\cf10 self\cf4 .master, \cf11 height\cf4 =\cf7 20\cf4 , \cf11 width\cf4 =\cf7 40\cf4 , \cf11 state\cf4 =DISABLED)\
        \cf10 self\cf4 .parser_text = Text(\cf10 self\cf4 .master, \cf11 height\cf4 =\cf7 20\cf4 , \cf11 width\cf4 =\cf7 40\cf4 , \cf11 state\cf4 =DISABLED)\
\
        \cf5 # Creating buttons\
        \cf10 self\cf4 .next_button = Button(\cf10 self\cf4 .master, \cf11 text\cf4 =\cf6 "Next Line"\cf4 , \cf11 command\cf4 =\cf10 self\cf4 .process_next_line)\
        \cf10 self\cf4 .quit_button = Button(\cf10 self\cf4 .master, \cf11 text\cf4 =\cf6 "Quit"\cf4 , \cf11 command\cf4 =\cf10 self\cf4 .master.quit)\
\
        \cf5 # Positioning the widgets side by side using grid\
        \cf10 self\cf4 .input_label.grid(\cf11 row\cf4 =\cf7 0\cf4 , \cf11 column\cf4 =\cf7 0\cf4 , \cf11 padx\cf4 =\cf7 10\cf4 , \cf11 pady\cf4 =\cf7 10\cf4 )\
        \cf10 self\cf4 .output_label.grid(\cf11 row\cf4 =\cf7 0\cf4 , \cf11 column\cf4 =\cf7 1\cf4 , \cf11 padx\cf4 =\cf7 10\cf4 , \cf11 pady\cf4 =\cf7 10\cf4 )\
        \cf10 self\cf4 .parser_label.grid(\cf11 row\cf4 =\cf7 0\cf4 , \cf11 column\cf4 =\cf7 2\cf4 , \cf11 padx\cf4 =\cf7 10\cf4 , \cf11 pady\cf4 =\cf7 10\cf4 )\
        \cf10 self\cf4 .input_text.grid(\cf11 row\cf4 =\cf7 1\cf4 , \cf11 column\cf4 =\cf7 0\cf4 , \cf11 padx\cf4 =\cf7 10\cf4 , \cf11 pady\cf4 =\cf7 10\cf4 , \cf11 sticky\cf4 =\cf6 "nsew"\cf4 )\
        \cf10 self\cf4 .output_text.grid(\cf11 row\cf4 =\cf7 1\cf4 , \cf11 column\cf4 =\cf7 1\cf4 , \cf11 padx\cf4 =\cf7 10\cf4 , \cf11 pady\cf4 =\cf7 10\cf4 , \cf11 sticky\cf4 =\cf6 "nsew"\cf4 )\
        \cf10 self\cf4 .parser_text.grid(\cf11 row\cf4 =\cf7 1\cf4 , \cf11 column\cf4 =\cf7 2\cf4 , \cf11 padx\cf4 =\cf7 10\cf4 , \cf11 pady\cf4 =\cf7 10\cf4 , \cf11 sticky\cf4 =\cf6 "nsew"\cf4 )\
        \cf10 self\cf4 .line_number_label.grid(\cf11 row\cf4 =\cf7 2\cf4 , \cf11 column\cf4 =\cf7 0\cf4 , \cf11 sticky\cf4 =W, \cf11 padx\cf4 =\cf7 10\cf4 , \cf11 pady\cf4 =\cf7 10\cf4 )\
        \cf10 self\cf4 .next_button.grid(\cf11 row\cf4 =\cf7 2\cf4 , \cf11 column\cf4 =\cf7 0\cf4 , \cf11 sticky\cf4 =E, \cf11 padx\cf4 =\cf7 10\cf4 , \cf11 pady\cf4 =\cf7 10\cf4 )\
        \cf10 self\cf4 .quit_button.grid(\cf11 row\cf4 =\cf7 2\cf4 , \cf11 column\cf4 =\cf7 1\cf4 , \cf11 sticky\cf4 =W, \cf11 padx\cf4 =\cf7 10\cf4 , \cf11 pady\cf4 =\cf7 10\cf4 )\
\
        \cf5 # Initialize line counter and source code lines\
        \cf10 self\cf4 .current_line = \cf7 0\
        \cf10 self\cf4 .source_lines = []\
\
    \cf2 def \cf8 process_next_line\cf4 (\cf10 self\cf4 ):\
        \cf2 if \cf10 self\cf4 .current_line == \cf7 0\cf4 :\
            input_text = \cf10 self\cf4 .input_text.get(\cf6 "1.0"\cf4 , END)\
            \cf10 self\cf4 .source_lines = input_text.splitlines()\
\
        \cf2 if \cf10 self\cf4 .current_line < \cf12 len\cf4 (\cf10 self\cf4 .source_lines):\
            line = \cf10 self\cf4 .source_lines[\cf10 self\cf4 .current_line]\
            tokens = CutOneLineTokens(line)\
\
            \cf5 # Append tokens to the output\
            \cf10 self\cf4 .output_text.config(\cf11 state\cf4 =NORMAL)\
            \cf2 for \cf4 token \cf2 in \cf4 tokens:\
                \cf10 self\cf4 .output_text.insert(END, token + \cf6 '\cf2 \\n\cf6 '\cf4 )\
            \cf10 self\cf4 .output_text.insert(END, \cf6 '\cf2 \\n\cf6 '\cf4 )  \cf5 # Extra newline for spacing\
            \cf10 self\cf4 .output_text.config(\cf11 state\cf4 =DISABLED)\
\
            \cf5 # Update current line and line number label\
            \cf10 self\cf4 .current_line += \cf7 1\
            \cf10 self\cf4 .line_number_label.config(\cf11 text\cf4 =\cf6 f"Current Processing Line: \cf2 \{\cf10 self\cf4 .current_line\cf2 \}\cf6 "\cf4 )\
\
            \cf5 # Parsing\
            \cf10 self\cf4 .parser_text.config(\cf11 state\cf4 =NORMAL)\
            \cf2 if \cf4 line.strip().startswith(\cf6 "if"\cf4 ):\
                parse_result = parse_if_statement(tokens)\
            \cf2 elif \cf6 '=' \cf2 in \cf4 line:\
                parse_result = parse_math_expression(tokens)\
            \cf2 elif \cf4 line.strip().startswith(\cf6 "print"\cf4 ):\
                parse_result = parse_print_statement(tokens)\
            \cf2 else\cf4 :\
                parse_result = [\cf6 "Unknown statement type"\cf4 ]\
\
            \cf2 for \cf4 step \cf2 in \cf4 parse_result:\
                \cf10 self\cf4 .parser_text.insert(END, step + \cf6 '\cf2 \\n\cf6 '\cf4 )\
            \cf10 self\cf4 .parser_text.insert(END, \cf6 '\cf2 \\n\cf6 '\cf4 )  \cf5 # Extra newline for spacing\
            \cf10 self\cf4 .parser_text.config(\cf11 state\cf4 =DISABLED)\
\
\cf5 # Main function to create and run the GUI\
\cf2 if \cf4 __name__ == \cf6 '__main__'\cf4 :\
    root = Tk()\
    lexer_gui = LexerGUI(root)\
    root.mainloop()\
}